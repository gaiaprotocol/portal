/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export declare namespace IGaiaBridge {
  export type TokenDataToBeBridgedStruct = {
    tokenType: BigNumberish;
    tokenName: string;
    tokenAddress: AddressLike;
    ids: BigNumberish[];
    amounts: BigNumberish[];
  };

  export type TokenDataToBeBridgedStructOutput = [
    tokenType: bigint,
    tokenName: string,
    tokenAddress: string,
    ids: bigint[],
    amounts: bigint[]
  ] & {
    tokenType: bigint;
    tokenName: string;
    tokenAddress: string;
    ids: bigint[];
    amounts: bigint[];
  };

  export type TokenInfoStruct = { token: AddressLike; isTransferType: boolean };

  export type TokenInfoStructOutput = [
    token: string,
    isTransferType: boolean
  ] & { token: string; isTransferType: boolean };
}

export declare namespace IGaiaMultisig {
  export type CompactSigStruct = { r: BytesLike; _vs: BytesLike };

  export type CompactSigStructOutput = [r: string, _vs: string] & {
    r: string;
    _vs: string;
  };
}

export interface GaiaBridgeInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "BATCH_TRANSFER_LIMIT"
      | "addSigner"
      | "emergencyWithdrawTokens"
      | "feeDB"
      | "getSigners"
      | "isSigner"
      | "isTokensReceived"
      | "onERC1155BatchReceived"
      | "onERC1155Received"
      | "paused"
      | "quorum"
      | "receiveETH"
      | "receiveTokens"
      | "removeSigner"
      | "sendETH"
      | "sendTokens"
      | "sendingCounts"
      | "sentAt"
      | "setPause"
      | "setTokenInfo"
      | "signersLength"
      | "signingNonce"
      | "supportsInterface"
      | "tokenHash"
      | "tokenInfo"
      | "updateFeeDB"
      | "updateQuorum"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AddSigner"
      | "Paused"
      | "ReceiveETH"
      | "ReceiveTokens"
      | "RemoveSigner"
      | "SendETH"
      | "SendTokens"
      | "SetTokenInfo"
      | "TransferFee"
      | "Unpaused"
      | "UpdateFeeDB"
      | "UpdateQuorum"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "BATCH_TRANSFER_LIMIT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addSigner",
    values: [AddressLike, IGaiaMultisig.CompactSigStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "emergencyWithdrawTokens",
    values: [
      IGaiaBridge.TokenDataToBeBridgedStruct[],
      AddressLike,
      IGaiaMultisig.CompactSigStruct[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "feeDB", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getSigners",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isSigner",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isTokensReceived",
    values: [AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [
      AddressLike,
      AddressLike,
      BigNumberish[],
      BigNumberish[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(functionFragment: "quorum", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "receiveETH",
    values: [
      AddressLike,
      BigNumberish,
      AddressLike,
      BigNumberish,
      BigNumberish,
      IGaiaMultisig.CompactSigStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "receiveTokens",
    values: [
      AddressLike,
      BigNumberish,
      AddressLike,
      IGaiaBridge.TokenDataToBeBridgedStruct,
      BigNumberish,
      BytesLike,
      IGaiaMultisig.CompactSigStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeSigner",
    values: [AddressLike, IGaiaMultisig.CompactSigStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "sendETH",
    values: [
      BigNumberish,
      AddressLike,
      BigNumberish,
      BytesLike,
      IGaiaMultisig.CompactSigStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sendTokens",
    values: [
      BigNumberish,
      AddressLike,
      IGaiaBridge.TokenDataToBeBridgedStruct,
      BytesLike,
      IGaiaMultisig.CompactSigStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sendingCounts",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sentAt",
    values: [AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPause",
    values: [boolean, IGaiaMultisig.CompactSigStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenInfo",
    values: [
      BytesLike[],
      AddressLike[],
      boolean[],
      IGaiaMultisig.CompactSigStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "signersLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "signingNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenHash",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenInfo",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateFeeDB",
    values: [AddressLike, IGaiaMultisig.CompactSigStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "updateQuorum",
    values: [BigNumberish, IGaiaMultisig.CompactSigStruct[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "BATCH_TRANSFER_LIMIT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addSigner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "emergencyWithdrawTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "feeDB", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getSigners", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isSigner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isTokensReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "quorum", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "receiveETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "receiveTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sendETH", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sendTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sendingCounts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sentAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setPause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTokenInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signersLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signingNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "tokenHash", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateFeeDB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateQuorum",
    data: BytesLike
  ): Result;
}

export namespace AddSignerEvent {
  export type InputTuple = [signer: AddressLike];
  export type OutputTuple = [signer: string];
  export interface OutputObject {
    signer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReceiveETHEvent {
  export type InputTuple = [
    sender: AddressLike,
    fromChainId: BigNumberish,
    receiver: AddressLike,
    amount: BigNumberish,
    sendingId: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    fromChainId: bigint,
    receiver: string,
    amount: bigint,
    sendingId: bigint
  ];
  export interface OutputObject {
    sender: string;
    fromChainId: bigint;
    receiver: string;
    amount: bigint;
    sendingId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReceiveTokensEvent {
  export type InputTuple = [
    sender: AddressLike,
    fromChainId: BigNumberish,
    receiver: AddressLike,
    tokenData: IGaiaBridge.TokenDataToBeBridgedStruct,
    sendingId: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    fromChainId: bigint,
    receiver: string,
    tokenData: IGaiaBridge.TokenDataToBeBridgedStructOutput,
    sendingId: bigint
  ];
  export interface OutputObject {
    sender: string;
    fromChainId: bigint;
    receiver: string;
    tokenData: IGaiaBridge.TokenDataToBeBridgedStructOutput;
    sendingId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RemoveSignerEvent {
  export type InputTuple = [signer: AddressLike];
  export type OutputTuple = [signer: string];
  export interface OutputObject {
    signer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SendETHEvent {
  export type InputTuple = [
    sender: AddressLike,
    toChainId: BigNumberish,
    receiver: AddressLike,
    amount: BigNumberish,
    sendingId: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    toChainId: bigint,
    receiver: string,
    amount: bigint,
    sendingId: bigint
  ];
  export interface OutputObject {
    sender: string;
    toChainId: bigint;
    receiver: string;
    amount: bigint;
    sendingId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SendTokensEvent {
  export type InputTuple = [
    sender: AddressLike,
    toChainId: BigNumberish,
    receiver: AddressLike,
    tokenData: IGaiaBridge.TokenDataToBeBridgedStruct,
    sendingId: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    toChainId: bigint,
    receiver: string,
    tokenData: IGaiaBridge.TokenDataToBeBridgedStructOutput,
    sendingId: bigint
  ];
  export interface OutputObject {
    sender: string;
    toChainId: bigint;
    receiver: string;
    tokenData: IGaiaBridge.TokenDataToBeBridgedStructOutput;
    sendingId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SetTokenInfoEvent {
  export type InputTuple = [
    tokenHash: BytesLike,
    tokenAddress: AddressLike,
    isTransferType: boolean
  ];
  export type OutputTuple = [
    tokenHash: string,
    tokenAddress: string,
    isTransferType: boolean
  ];
  export interface OutputObject {
    tokenHash: string;
    tokenAddress: string;
    isTransferType: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferFeeEvent {
  export type InputTuple = [
    feeToken: AddressLike,
    user: AddressLike,
    feeRecipient: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [
    feeToken: string,
    user: string,
    feeRecipient: string,
    amount: bigint
  ];
  export interface OutputObject {
    feeToken: string;
    user: string;
    feeRecipient: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UnpausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpdateFeeDBEvent {
  export type InputTuple = [newFeeDB: AddressLike];
  export type OutputTuple = [newFeeDB: string];
  export interface OutputObject {
    newFeeDB: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpdateQuorumEvent {
  export type InputTuple = [newQuorum: BigNumberish];
  export type OutputTuple = [newQuorum: bigint];
  export interface OutputObject {
    newQuorum: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface GaiaBridge extends BaseContract {
  connect(runner?: ContractRunner | null): GaiaBridge;
  waitForDeployment(): Promise<this>;

  interface: GaiaBridgeInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  BATCH_TRANSFER_LIMIT: TypedContractMethod<[], [bigint], "view">;

  addSigner: TypedContractMethod<
    [signer: AddressLike, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;

  emergencyWithdrawTokens: TypedContractMethod<
    [
      tokenData: IGaiaBridge.TokenDataToBeBridgedStruct[],
      recipient: AddressLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "nonpayable"
  >;

  feeDB: TypedContractMethod<[], [string], "view">;

  getSigners: TypedContractMethod<[], [string[]], "view">;

  isSigner: TypedContractMethod<[signer: AddressLike], [boolean], "view">;

  isTokensReceived: TypedContractMethod<
    [sender: AddressLike, fromChainId: BigNumberish, sendingId: BigNumberish],
    [boolean],
    "view"
  >;

  onERC1155BatchReceived: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike
    ],
    [string],
    "view"
  >;

  onERC1155Received: TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike
    ],
    [string],
    "view"
  >;

  paused: TypedContractMethod<[], [boolean], "view">;

  quorum: TypedContractMethod<[], [bigint], "view">;

  receiveETH: TypedContractMethod<
    [
      sender: AddressLike,
      fromChainId: BigNumberish,
      receiver: AddressLike,
      amount: BigNumberish,
      sendingId: BigNumberish,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "nonpayable"
  >;

  receiveTokens: TypedContractMethod<
    [
      sender: AddressLike,
      fromChainId: BigNumberish,
      receiver: AddressLike,
      tokenData: IGaiaBridge.TokenDataToBeBridgedStruct,
      sendingId: BigNumberish,
      feeData: BytesLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "payable"
  >;

  removeSigner: TypedContractMethod<
    [signer: AddressLike, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;

  sendETH: TypedContractMethod<
    [
      toChainId: BigNumberish,
      receiver: AddressLike,
      amount: BigNumberish,
      data: BytesLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [bigint],
    "payable"
  >;

  sendTokens: TypedContractMethod<
    [
      toChainId: BigNumberish,
      receiver: AddressLike,
      tokenData: IGaiaBridge.TokenDataToBeBridgedStruct,
      data: BytesLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [bigint],
    "payable"
  >;

  sendingCounts: TypedContractMethod<
    [sender: AddressLike, toChainId: BigNumberish],
    [bigint],
    "view"
  >;

  sentAt: TypedContractMethod<
    [sender: AddressLike, toChainId: BigNumberish, sendingId: BigNumberish],
    [bigint],
    "view"
  >;

  setPause: TypedContractMethod<
    [status: boolean, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;

  setTokenInfo: TypedContractMethod<
    [
      tokenHashes: BytesLike[],
      tokenAddresses: AddressLike[],
      isTransferTypes: boolean[],
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "nonpayable"
  >;

  signersLength: TypedContractMethod<[], [bigint], "view">;

  signingNonce: TypedContractMethod<[], [bigint], "view">;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  tokenHash: TypedContractMethod<
    [tokenType: BigNumberish, tokenName: string],
    [string],
    "view"
  >;

  tokenInfo: TypedContractMethod<
    [_tokenHash: BytesLike],
    [IGaiaBridge.TokenInfoStructOutput],
    "view"
  >;

  updateFeeDB: TypedContractMethod<
    [newFeeDB: AddressLike, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;

  updateQuorum: TypedContractMethod<
    [newQuorum: BigNumberish, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "BATCH_TRANSFER_LIMIT"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "addSigner"
  ): TypedContractMethod<
    [signer: AddressLike, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "emergencyWithdrawTokens"
  ): TypedContractMethod<
    [
      tokenData: IGaiaBridge.TokenDataToBeBridgedStruct[],
      recipient: AddressLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "feeDB"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getSigners"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "isSigner"
  ): TypedContractMethod<[signer: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isTokensReceived"
  ): TypedContractMethod<
    [sender: AddressLike, fromChainId: BigNumberish, sendingId: BigNumberish],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "onERC1155BatchReceived"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: BigNumberish[],
      arg3: BigNumberish[],
      arg4: BytesLike
    ],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "onERC1155Received"
  ): TypedContractMethod<
    [
      arg0: AddressLike,
      arg1: AddressLike,
      arg2: BigNumberish,
      arg3: BigNumberish,
      arg4: BytesLike
    ],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "paused"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "quorum"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "receiveETH"
  ): TypedContractMethod<
    [
      sender: AddressLike,
      fromChainId: BigNumberish,
      receiver: AddressLike,
      amount: BigNumberish,
      sendingId: BigNumberish,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "receiveTokens"
  ): TypedContractMethod<
    [
      sender: AddressLike,
      fromChainId: BigNumberish,
      receiver: AddressLike,
      tokenData: IGaiaBridge.TokenDataToBeBridgedStruct,
      sendingId: BigNumberish,
      feeData: BytesLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "removeSigner"
  ): TypedContractMethod<
    [signer: AddressLike, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sendETH"
  ): TypedContractMethod<
    [
      toChainId: BigNumberish,
      receiver: AddressLike,
      amount: BigNumberish,
      data: BytesLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "sendTokens"
  ): TypedContractMethod<
    [
      toChainId: BigNumberish,
      receiver: AddressLike,
      tokenData: IGaiaBridge.TokenDataToBeBridgedStruct,
      data: BytesLike,
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "sendingCounts"
  ): TypedContractMethod<
    [sender: AddressLike, toChainId: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "sentAt"
  ): TypedContractMethod<
    [sender: AddressLike, toChainId: BigNumberish, sendingId: BigNumberish],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "setPause"
  ): TypedContractMethod<
    [status: boolean, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTokenInfo"
  ): TypedContractMethod<
    [
      tokenHashes: BytesLike[],
      tokenAddresses: AddressLike[],
      isTransferTypes: boolean[],
      sigs: IGaiaMultisig.CompactSigStruct[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "signersLength"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "signingNonce"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "tokenHash"
  ): TypedContractMethod<
    [tokenType: BigNumberish, tokenName: string],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "tokenInfo"
  ): TypedContractMethod<
    [_tokenHash: BytesLike],
    [IGaiaBridge.TokenInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "updateFeeDB"
  ): TypedContractMethod<
    [newFeeDB: AddressLike, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateQuorum"
  ): TypedContractMethod<
    [newQuorum: BigNumberish, sigs: IGaiaMultisig.CompactSigStruct[]],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "AddSigner"
  ): TypedContractEvent<
    AddSignerEvent.InputTuple,
    AddSignerEvent.OutputTuple,
    AddSignerEvent.OutputObject
  >;
  getEvent(
    key: "Paused"
  ): TypedContractEvent<
    PausedEvent.InputTuple,
    PausedEvent.OutputTuple,
    PausedEvent.OutputObject
  >;
  getEvent(
    key: "ReceiveETH"
  ): TypedContractEvent<
    ReceiveETHEvent.InputTuple,
    ReceiveETHEvent.OutputTuple,
    ReceiveETHEvent.OutputObject
  >;
  getEvent(
    key: "ReceiveTokens"
  ): TypedContractEvent<
    ReceiveTokensEvent.InputTuple,
    ReceiveTokensEvent.OutputTuple,
    ReceiveTokensEvent.OutputObject
  >;
  getEvent(
    key: "RemoveSigner"
  ): TypedContractEvent<
    RemoveSignerEvent.InputTuple,
    RemoveSignerEvent.OutputTuple,
    RemoveSignerEvent.OutputObject
  >;
  getEvent(
    key: "SendETH"
  ): TypedContractEvent<
    SendETHEvent.InputTuple,
    SendETHEvent.OutputTuple,
    SendETHEvent.OutputObject
  >;
  getEvent(
    key: "SendTokens"
  ): TypedContractEvent<
    SendTokensEvent.InputTuple,
    SendTokensEvent.OutputTuple,
    SendTokensEvent.OutputObject
  >;
  getEvent(
    key: "SetTokenInfo"
  ): TypedContractEvent<
    SetTokenInfoEvent.InputTuple,
    SetTokenInfoEvent.OutputTuple,
    SetTokenInfoEvent.OutputObject
  >;
  getEvent(
    key: "TransferFee"
  ): TypedContractEvent<
    TransferFeeEvent.InputTuple,
    TransferFeeEvent.OutputTuple,
    TransferFeeEvent.OutputObject
  >;
  getEvent(
    key: "Unpaused"
  ): TypedContractEvent<
    UnpausedEvent.InputTuple,
    UnpausedEvent.OutputTuple,
    UnpausedEvent.OutputObject
  >;
  getEvent(
    key: "UpdateFeeDB"
  ): TypedContractEvent<
    UpdateFeeDBEvent.InputTuple,
    UpdateFeeDBEvent.OutputTuple,
    UpdateFeeDBEvent.OutputObject
  >;
  getEvent(
    key: "UpdateQuorum"
  ): TypedContractEvent<
    UpdateQuorumEvent.InputTuple,
    UpdateQuorumEvent.OutputTuple,
    UpdateQuorumEvent.OutputObject
  >;

  filters: {
    "AddSigner(address)": TypedContractEvent<
      AddSignerEvent.InputTuple,
      AddSignerEvent.OutputTuple,
      AddSignerEvent.OutputObject
    >;
    AddSigner: TypedContractEvent<
      AddSignerEvent.InputTuple,
      AddSignerEvent.OutputTuple,
      AddSignerEvent.OutputObject
    >;

    "Paused(address)": TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;
    Paused: TypedContractEvent<
      PausedEvent.InputTuple,
      PausedEvent.OutputTuple,
      PausedEvent.OutputObject
    >;

    "ReceiveETH(address,uint256,address,uint256,uint256)": TypedContractEvent<
      ReceiveETHEvent.InputTuple,
      ReceiveETHEvent.OutputTuple,
      ReceiveETHEvent.OutputObject
    >;
    ReceiveETH: TypedContractEvent<
      ReceiveETHEvent.InputTuple,
      ReceiveETHEvent.OutputTuple,
      ReceiveETHEvent.OutputObject
    >;

    "ReceiveTokens(address,uint256,address,tuple,uint256)": TypedContractEvent<
      ReceiveTokensEvent.InputTuple,
      ReceiveTokensEvent.OutputTuple,
      ReceiveTokensEvent.OutputObject
    >;
    ReceiveTokens: TypedContractEvent<
      ReceiveTokensEvent.InputTuple,
      ReceiveTokensEvent.OutputTuple,
      ReceiveTokensEvent.OutputObject
    >;

    "RemoveSigner(address)": TypedContractEvent<
      RemoveSignerEvent.InputTuple,
      RemoveSignerEvent.OutputTuple,
      RemoveSignerEvent.OutputObject
    >;
    RemoveSigner: TypedContractEvent<
      RemoveSignerEvent.InputTuple,
      RemoveSignerEvent.OutputTuple,
      RemoveSignerEvent.OutputObject
    >;

    "SendETH(address,uint256,address,uint256,uint256)": TypedContractEvent<
      SendETHEvent.InputTuple,
      SendETHEvent.OutputTuple,
      SendETHEvent.OutputObject
    >;
    SendETH: TypedContractEvent<
      SendETHEvent.InputTuple,
      SendETHEvent.OutputTuple,
      SendETHEvent.OutputObject
    >;

    "SendTokens(address,uint256,address,tuple,uint256)": TypedContractEvent<
      SendTokensEvent.InputTuple,
      SendTokensEvent.OutputTuple,
      SendTokensEvent.OutputObject
    >;
    SendTokens: TypedContractEvent<
      SendTokensEvent.InputTuple,
      SendTokensEvent.OutputTuple,
      SendTokensEvent.OutputObject
    >;

    "SetTokenInfo(bytes32,address,bool)": TypedContractEvent<
      SetTokenInfoEvent.InputTuple,
      SetTokenInfoEvent.OutputTuple,
      SetTokenInfoEvent.OutputObject
    >;
    SetTokenInfo: TypedContractEvent<
      SetTokenInfoEvent.InputTuple,
      SetTokenInfoEvent.OutputTuple,
      SetTokenInfoEvent.OutputObject
    >;

    "TransferFee(address,address,address,uint256)": TypedContractEvent<
      TransferFeeEvent.InputTuple,
      TransferFeeEvent.OutputTuple,
      TransferFeeEvent.OutputObject
    >;
    TransferFee: TypedContractEvent<
      TransferFeeEvent.InputTuple,
      TransferFeeEvent.OutputTuple,
      TransferFeeEvent.OutputObject
    >;

    "Unpaused(address)": TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
    Unpaused: TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;

    "UpdateFeeDB(address)": TypedContractEvent<
      UpdateFeeDBEvent.InputTuple,
      UpdateFeeDBEvent.OutputTuple,
      UpdateFeeDBEvent.OutputObject
    >;
    UpdateFeeDB: TypedContractEvent<
      UpdateFeeDBEvent.InputTuple,
      UpdateFeeDBEvent.OutputTuple,
      UpdateFeeDBEvent.OutputObject
    >;

    "UpdateQuorum(uint256)": TypedContractEvent<
      UpdateQuorumEvent.InputTuple,
      UpdateQuorumEvent.OutputTuple,
      UpdateQuorumEvent.OutputObject
    >;
    UpdateQuorum: TypedContractEvent<
      UpdateQuorumEvent.InputTuple,
      UpdateQuorumEvent.OutputTuple,
      UpdateQuorumEvent.OutputObject
    >;
  };
}
